import numpy as np      # Work with matrices

#   Queue module
#       queue.Queue(maxsize = 0) is FIFO
#       queue.LifoQueue(maxsize = 0) is LIFO
#       queue.PriorityQueue(maxsize = 0) returns lowest number first
#           pop the lowest heuristic value
#           maybe use this one for the 2 heursitics
import queue

# goal_state = [[1,2,3],[4,5,6],[7,8,0]]      # 0 is the blank space
# Create Goal State
goal_state = np.zeros((3,3),int)
value = 1
for i in range (0,3):
    for j in range(0,3):
        if (i < 2 or j < 2):
            goal_state[i][j] = value
        else:
            goal_state[i][j] = 0
        value = value + 1
print(goal_state)

class Tree:
    # Constructor. The 8-puzzle can have up to 3 children
    def __init__(self,state,r,c,left=None,mid=None,right=None):
        self.state = state      # States will be the array of the board
        self.left = left
        self.mid = mid
        self.right = right
        self.r = r              # location of blank space via rows
        self.c = c              # location of blank space via columns

    # Return the value at that node (i.e. 1,2,3...,or 0)
    def __str__(self):
        return str(self.state)

    def __goal__(self):
        if (self.state == goal_state):
            return True


def display(tree):
    print(tree)

'''
            123
            450
            786

120         123        123
453         405        456
786         786        780

'''

ori = np.zeros((3,3),int)
display(ori)

fleft = Tree([[1,2,0],[4,5,3],[7,8,6]],0,2)     # Left child
display(fleft)
fmid = Tree([[1,2,3],[4,5,0],[7,8,6]],1,2)      # Middle child
fright = Tree([[1,2,3],[4,5,6],[7,8,0]],2,2)    # right child

hello = Tree([[1,2,3],[4,5,0],[7,8,6]],1,2,fleft, fmid, fright)    # Create a Tree object
print(str(hello))   # Print the value at the tree
display(hello)

'''
function general_search(problem, QUEUEING_FUNCTION):
    nodes = make_queue(make_node(problem.INITIAL_STATE)
    do
        if empty(nodes):
            return failure
        node = REMOVE_FRONT(nodes)
        if (problem.GOAL_TEST(node.STATE) == true)
            return success and the node
        nodes = QUEUEING_FUNCTION(nodes, EXPAND(node, problem.OPERATORS))
    end

'''

# Expand the nodes. i and j are the indexes of the blank space
def expand(node, i, j):
    list_nodes = []
    start_node = np.copy(node) # Have to do this away. If used equal, it refers to same object

    if (i > 0):
        print("First expanded node")
        start_node[i][j] = node[i-1][j]
        start_node[i-1][j] = 0
        print(start_node)
        list_nodes.append(start_node)
        start_node = np.copy(node)
    if (i < 2):
        print("Second expanded node")
        start_node[i][j] = node[i+1][j]
        start_node[i+1][j] = 0
        print(start_node)
        list_nodes.append(start_node)
        start_node = np.copy(node)

    if (j > 0):
        print("Third expanded node")
        start_node[i][j] = node[i][j-1]
        start_node[i][j-1] = 0
        print(start_node)
        list_nodes.append(start_node)
        start_node = np.copy(node)
    if (j < 2):
        print("Fourth expanded node")
        start_node[i][j] = node[i][j+1]
        start_node[i][j+1] = 0
        print(start_node)
        list_nodes.append(start_node)
        start_node = np.copy(node)
    return list_nodes

def blank_space(node):
    for i in range(0,3):
        for j in range(0,3):
            if (node[i][j] == 0):
                print(i,j)
                return (i,j)

# Infinite capacity
# Using FIFO Queue
def Uniform_Cost_Search(node):
    # Create the queue and test the compare the inputted node with the goal_state
    #   because there is no do-while loop in python
    nodes = queue.Queue()
    encountered_nodes = []
    if (np.array_equal(node,goal_state)):
        print("Found the state")
        return True
    else:
        print("Not correct yet")
    # Add nodes to list of nodes that we've seen
    print("Adding to list of seen nodes:")
    encountered_nodes.append(node)
    for i in range(0, len(encountered_nodes)):
        print(encountered_nodes[i])





    # Create the children states. Then call UCS on children
    # Throw each on the queue
    # Pop one off the queue. Check if equal to goal state
    # If not equal, expand children. Throw on queue
    # Repeat steps 3-4 until nothing is on the queue.
    # If the end is reach without finding goal state, return false

# Calculates the number of tiles
# Ignores placement of blank tile
def Misplaced_Tile(tree):
    count = 0
    for i in range(0,3):
        for j in range(0,3):
            if( (tree[i][j] != goal_state[i][j]) and tree[i][j] != 0):
                count = count + 1
    return count

'''
1 4 3     1 2 3
2 5 7     4 5 6
6 8       7 8
'''

random_state = np.zeros((3,3),int)
random_state[0][0] = 1
random_state[0][1] = 1
random_state[0][2] = 1
random_state[1][0] = 0
random_state[1][1] = 0
random_state[1][2] = 0
random_state[2][0] = 0
random_state[2][1] = 0
random_state[2][2] = 0
print(random_state)
print(Misplaced_Tile(random_state))

print("Testing Perfect Board")
tmp = np.zeros((3,3),int)
tmp[0][0] = 1
tmp[0][1] = 2
tmp[0][2] = 3
tmp[1][0] = 4
tmp[1][1] = 5
tmp[1][2] = 6
tmp[2][0] = 7
tmp[2][1] = 0
tmp[2][2] = 8
print(tmp)
print(Misplaced_Tile(tmp))
print("\nTesting Uniform Cost Search")
Uniform_Cost_Search(tmp)

print("Location of blank space:\n", blank_space(tmp))

print("Calling the expand function: ")
expand(tmp,2,1)
